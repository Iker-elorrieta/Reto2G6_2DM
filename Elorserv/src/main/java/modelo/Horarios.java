package modelo;
// Generated 13 ene 2026, 8:47:05 by Hibernate Tools 6.5.1.Final

import java.sql.Timestamp;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.reto2.elorserv.HibernateUtil;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.query.Query;
import org.hibernate.Transaction; 

/**
 * Horarios generated by hbm2java
 */
public class Horarios implements java.io.Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Integer id;
	@JsonIgnore
	private Users users;
	private Modulos modulos;
	private String dia;
	private byte hora;
	private String aula;
	private String observaciones;
	private Timestamp createdAt;
	private Timestamp updatedAt;

	public Horarios() {
	}

	public Horarios(Users users, Modulos modulos, String dia, byte hora) {
		this.users = users;
		this.modulos = modulos;
		this.dia = dia;
		this.hora = hora;
	}

	public Horarios(Users users, Modulos modulos, String dia, byte hora, String aula, String observaciones,
			Timestamp createdAt, Timestamp updatedAt) {
		this.users = users;
		this.modulos = modulos;
		this.dia = dia;
		this.hora = hora;
		this.aula = aula;
		this.observaciones = observaciones;
		this.createdAt = createdAt;
		this.updatedAt = updatedAt;
	}

	public Horarios(Horarios otro) {
	    this.users = otro.getUsers() != null ? new Users(otro.getUsers()) : null;
	    this.modulos = otro.getModulos() != null ? new Modulos(otro.getModulos()): null;
	    this.id = otro.getId();
	    this.dia = otro.getDia();
	    this.hora = otro.getHora();
	    this.aula = otro.getAula();
	    this.observaciones = otro.getObservaciones();
	    this.createdAt = otro.getCreatedAt();
	    this.updatedAt = otro.getUpdatedAt();
	}

	public Integer getId() {
		return this.id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public Users getUsers() {
		return this.users;
	}

	public void setUsers(Users users) {
		this.users = users;
	}

	public Modulos getModulos() {
		return this.modulos;
	}

	public void setModulos(Modulos modulos) {
		this.modulos = modulos;
	}

	public String getDia() {
		return this.dia.trim().toUpperCase();
	}

	public void setDia(String dia) {
		this.dia = dia;
	}

	public byte getHora() {
		return this.hora;
	}

	public void setHora(byte hora) {
		this.hora = hora;
	}

	public String getAula() {
		return this.aula;
	}

	public void setAula(String aula) {
		this.aula = aula;
	}

	public String getObservaciones() {
		return this.observaciones;
	}

	public void setObservaciones(String observaciones) {
		this.observaciones = observaciones;
	}

	public Timestamp getCreatedAt() {
		return this.createdAt;
	}

	public void setCreatedAt(Timestamp createdAt) {
		this.createdAt = createdAt;
	}

	public Timestamp getUpdatedAt() {
		return this.updatedAt;
	}

	public void setUpdatedAt(Timestamp updatedAt) {
		this.updatedAt = updatedAt;
	}
	
	/**
	 * Convierte un DayOfWeek en un string en español.
	 */
	private static String diaSemana(DayOfWeek day) {
		switch (day) {
		case MONDAY:
			return "LUNES";
		case TUESDAY:
			return "MARTES";
		case WEDNESDAY:
			return "MIERCOLES";
		case THURSDAY:
			return "JUEVES";
		case FRIDAY:
			return "VIERNES";
		case SATURDAY:
			return "SABADO";
		case SUNDAY:
			return "DOMINGO";
		default:
			return "";
		}
	}

	/**
	 * Comprueba si un horario coincide con la fecha/hora de una reunión.
	 */
	public boolean coincide(Timestamp fechaReunion) {
		LocalDateTime fechaR = fechaReunion.toLocalDateTime();
		String diaReunion = diaSemana(fechaR.getDayOfWeek());
		if (!getDia().equals(diaReunion)) {
			return false;
		}
		return (7+ hora) == (fechaR.getHour());
	}
	
	/**
	 * Devuelve los horarios de un usuario determinando su rol (alumno/profesor).
	 */
	public static List<Horarios> getHorariosByUserId(Integer userId) {
		Users user = new Users(userId).getUsuarioPorID();
		switch (user.getTipos().getName()) {
			case "alumno":
				return getHorariosByAlumnoId(userId);
			case "profesor":
				return getHorariosByProfesorId(userId);
			default:
				throw new IllegalArgumentException("Rol no reconocido");
		}
	}
	/**
	 * Recupera los horarios de un alumno consultando sus matriculaciones.
	 */
	public static List<Horarios> getHorariosByAlumnoId(Integer alumnoId) {
		if (alumnoId == null) {
			throw new IllegalArgumentException("El id del alumno no puede ser nulo");
		}
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			String hql = "select h from Horarios h "
					+ "join h.modulos m "
					+ "join Matriculaciones mat "
					+ "where mat.users =  "+ alumnoId
					+ " and mat.ciclos = m.ciclos "
					+ "and mat.curso = m.curso";
			Query<Horarios> q = session.createQuery(hql, Horarios.class);
			q.list().replaceAll(h -> new Horarios(h));
			return q.list();
		}
	}
	/**
	 * Recupera los horarios de un profesor por su id.
	 */
	private static List<Horarios> getHorariosByProfesorId(Integer userId) {
		if (userId == null) {
			throw new IllegalArgumentException("El id del usuario no puede ser nulo");
		}
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			String hql = "from Horarios where users.id = :userId";
			Query<Horarios> q = session.createQuery(hql, Horarios.class);
			q.setParameter("userId", userId);
			q.list().replaceAll(h -> new Horarios(h));
			return q.list();
		}
	}
	/**
	 * Guarda un nuevo horario en la base de datos validando que usuario y módulo existan.
	 */
	public Horarios crearHorario() {
		if (getUsers() == null || getUsers().getId() == null) {
			throw new IllegalArgumentException("Usuario obligatorio para crear horario");
		}
		if (getModulos() == null || getModulos().getId() == null) {
			throw new IllegalArgumentException("Módulo obligatorio para crear horario");
		}
				setId(null);
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		Transaction tx = null;
		try (Session session = sesion.openSession()) {
			tx = session.beginTransaction();
			// Usar la sesión actual en lugar de abrir nuevas sesiones
			Users usuario = session.get(Users.class, getUsers().getId());
			Modulos modulo = session.get(Modulos.class, getModulos().getId());
			
			if (usuario == null) {
				throw new IllegalArgumentException("No se encontró el usuario con ID: " + getUsers().getId());
			}
			if (modulo == null) {
				throw new IllegalArgumentException("No se encontró el módulo con ID: " + getModulos().getId());
			}
			
			setUsers(usuario);
			setModulos(modulo);
			Timestamp now = new Timestamp(System.currentTimeMillis());
			if (getCreatedAt() == null) {
				setCreatedAt(now);
			}
			setUpdatedAt(now);
			session.persist(this);
			tx.commit();
			return new Horarios(this);
		} catch (IllegalArgumentException e) {
			if (tx != null) {
				tx.rollback();
			}
			throw e;
		} catch (Exception e) {
			if (tx != null) {
				tx.rollback();
			}
			throw new RuntimeException("Error al crear el horario: " + e.getMessage(), e);
		}
	}
}