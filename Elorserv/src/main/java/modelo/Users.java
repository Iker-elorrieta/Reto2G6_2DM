package modelo;
// Generated 13 ene 2026, 8:47:05 by Hibernate Tools 6.5.1.Final

import java.nio.charset.StandardCharsets;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.query.Query;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.reto2.elorserv.HibernateUtil;

/**
 * Users generated by hbm2java
 */
public class Users implements java.io.Serializable {

	private static final String AES_TRANSFORMATION = "AES/ECB/PKCS5Padding";
	private static final int AES_KEY_LENGTH = 16;
	private static final String ENV_KEY = System.getenv().getOrDefault("ELOR_AES_KEY", "ELORG6RETO2");
	private static final String CLIENT_ENV_KEY = System.getenv().getOrDefault("ELOR_CLIENT_AES_KEY", "CLNTS3CR3T202601");
	public static final String TIPO_CLIENTE = "CLIENTE";
	public static final String TIPO_SERVIDOR = "SERVIDOR";
	
	private static final long serialVersionUID = 1L;
	private Integer id;
	private Tipos tipos;
	private String email;
	private String username;
	private String password;
	private String nombre;
	private String apellidos;
	private String dni;
	private String direccion;
	private String telefono1;
	private String telefono2;
	private String argazkiaUrl;
	private Timestamp createdAt;
	private Timestamp updatedAt;
	@JsonIgnore
	private Set<Matriculaciones> matriculacioneses = new HashSet<Matriculaciones>(0);
	@JsonIgnore
	private Set<Reuniones> reunionesesForAlumnoId = new HashSet<Reuniones>(0);
	@JsonIgnore
	private Set<Horarios> horarioses = new HashSet<Horarios>(0);
	@JsonIgnore
	private Set<Reuniones> reunionesesForProfesorId = new HashSet<Reuniones>(0);

	public Users() {
		super();
	}

	public Users(Integer id) {
		super();
		this.id = id;
	}

	public Users(String username, String password) {
		this.username = username;
		this.password = password;
	}

	public Users(Integer id, String username, String email) {
		this.id = id;
		this.username = username;
		this.email = email;
	}

	public Users(Tipos tipos, String email, String username, String password) {
		this.tipos = tipos;
		this.email = email;
		this.username = username;
		this.password = password;
	}

	public Users(Tipos tipos, String email, String username, String password, String nombre, String apellidos,
			String dni, String direccion, String telefono1, String telefono2, String argazkiaUrl, Timestamp createdAt,
			Timestamp updatedAt, Set<Matriculaciones> matriculacioneses, Set<Reuniones> reunionesesForAlumnoId,
			Set<Horarios> horarioses, Set<Reuniones> reunionesesForProfesorId) {
		this.tipos = tipos;
		this.email = email;
		this.username = username;
		this.password = password;
		this.nombre = nombre;
		this.apellidos = apellidos;
		this.dni = dni;
		this.direccion = direccion;
		this.telefono1 = telefono1;
		this.telefono2 = telefono2;
		this.argazkiaUrl = argazkiaUrl;
		this.createdAt = createdAt;
		this.updatedAt = updatedAt;
		this.matriculacioneses = matriculacioneses;
		this.reunionesesForAlumnoId = reunionesesForAlumnoId;
		this.horarioses = horarioses;
		this.reunionesesForProfesorId = reunionesesForProfesorId;
	}

	public Users(Users otro) {
	    this.id = otro.getId();
	    this.email = otro.getEmail();
	    this.username = descifrar(otro.getUsername(), TIPO_SERVIDOR); 
	    this.password = otro.getPassword();
	    this.nombre = otro.getNombre();
	    this.apellidos = otro.getApellidos();
		this.dni = otro.getDni();
	    this.direccion = otro.getDireccion();
	    this.telefono1 = otro.getTelefono1();
	    this.telefono2 = otro.getTelefono2();
	    this.argazkiaUrl = otro.getArgazkiaUrl();
	    this.createdAt = otro.getCreatedAt();
	    this.updatedAt = otro.getUpdatedAt();	       
	    this.tipos =  new Tipos(otro.getTipos().getId(), otro.getTipos().getName(), otro.getTipos().getNameEu());
	}

	public Integer getId() {
		return this.id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public Tipos getTipos() {
		return this.tipos;
	}

	public void setTipos(Tipos tipos) {
		this.tipos = tipos;
	}

	public String getEmail() {
		return this.email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getUsername() {
		return this.username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return this.password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getNombre() {
		return this.nombre;
	}

	public void setNombre(String nombre) {
		this.nombre = nombre;
	}

	public String getApellidos() {
		return this.apellidos;
	}

	public void setApellidos(String apellidos) {
		this.apellidos = apellidos;
	}

	public String getDni() {
		return this.dni;
	}

	public void setDni(String dni) {
		this.dni = dni;
	}

	public String getDireccion() {
		return this.direccion;
	}

	public void setDireccion(String direccion) {
		this.direccion = direccion;
	}

	public String getTelefono1() {
		return this.telefono1;
	}

	public void setTelefono1(String telefono1) {
		this.telefono1 = telefono1;
	}

	public String getTelefono2() {
		return this.telefono2;
	}

	public void setTelefono2(String telefono2) {
		this.telefono2 = telefono2;
	}

	public String getArgazkiaUrl() {
		return this.argazkiaUrl;
	}

	public void setArgazkiaUrl(String argazkiaUrl) {
		this.argazkiaUrl = argazkiaUrl;
	}

	public Timestamp getCreatedAt() {
		return this.createdAt;
	}

	public void setCreatedAt(Timestamp createdAt) {
		this.createdAt = createdAt;
	}

	public Timestamp getUpdatedAt() {
		return this.updatedAt;
	}

	public void setUpdatedAt(Timestamp updatedAt) {
		this.updatedAt = updatedAt;
	}

	public Set<Matriculaciones> getMatriculacioneses() {
		return this.matriculacioneses;
	}

	public void setMatriculacioneses(Set<Matriculaciones> matriculacioneses) {
		this.matriculacioneses = matriculacioneses;
	}

	public Set<Reuniones> getReunionesesForAlumnoId() {
		return this.reunionesesForAlumnoId;
	}

	public void setReunionesesForAlumnoId(Set<Reuniones> reunionesesForAlumnoId) {
		this.reunionesesForAlumnoId = reunionesesForAlumnoId;
	}

	public Set<Horarios> getHorarioses() {
		return this.horarioses;
	}

	public void setHorarioses(Set<Horarios> horarioses) {
		this.horarioses = horarioses;
	}

	public Set<Reuniones> getReunionesesForProfesorId() {
		return this.reunionesesForProfesorId;
	}

	public void setReunionesesForProfesorId(Set<Reuniones> reunionesesForProfesorId) {
		this.reunionesesForProfesorId = reunionesesForProfesorId;
	}

	/**
	 * Valida las credenciales del usuario actual y devuelve el usuario si existen.
	 * Si se especifica un tipoObligatorio, también valida que el usuario tenga ese rol.
	*/
	public Users iniciarSesion(String tipoObligatorio) {
		if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty()) {
			throw new IllegalArgumentException("Usuario o contraseña incorrectos");
		}
		try {
			Users user = getUsuarioUsernameContraseña(tipoObligatorio);
			if (user == null && tipoObligatorio == null) {
				throw new RuntimeException("Credenciales inválidas");
			} else if (user == null && tipoObligatorio != null) {
				throw new RuntimeException("Credenciales inválidas o no tiene el rol requerido");
			}
			return user;

		} catch (Exception e) {
			if (tipoObligatorio != null) {
				throw new RuntimeException("Credenciales inválidas o no tiene el rol requerido");
			} else {
				throw new RuntimeException("Credenciales inválidas");
			}
		}
	}

	/**
	 * Busca en la base de datos un usuario que coincida con el username y password actuales.
	 * Si tipoObligatorio está definido, añade esa condición a la consulta.
	 */
	public Users getUsuarioUsernameContraseña(String tipoObligatorio) {
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		Session session = sesion.openSession();

		String hql = "from Users where username = ?1 and password = ?2";
		// Si se especifica un rol obligatorio, añadir la condición
		if (tipoObligatorio != null && !tipoObligatorio.isBlank()) {
			hql += " and tipos.name = :tipo";
		}

		Query<Users> q = session.createQuery(hql, Users.class);
		// Asignar parámetros cifrados (clave SERVIDOR -> DB)
		q.setParameter(1, cifrar(username, TIPO_SERVIDOR));
		q.setParameter(2, cifrar(password, TIPO_SERVIDOR));
		if (tipoObligatorio != null && !tipoObligatorio.isBlank()) {
			q.setParameter("tipo", tipoObligatorio);
		}
		Users resultado = q.uniqueResult();
		return resultado != null ? new Users(resultado) : null;
	}

	/**
	 * Recupera la información del usuario desde la base de datos por su id y devuelve una copia.
	 */
	@JsonIgnore
	public Users getUsuarioPorID() {
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		Session session = sesion.openSession();
		Users user = session.get(Users.class, getId());
		return new Users(user);
	}

	/**
	 * Recupera todos los usuarios que tienen el tipo/rol especificado.
	 */
	@JsonIgnore
	public static List<Users> getUsersByTipo(String nombre) {
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		Session session = sesion.openSession();
		String hql = "from Users where tipos.name = :nombre";
		Query<Users> q = session.createQuery(hql, Users.class);
		q.setParameter("nombre", nombre);
		List<Users> usuarios = new ArrayList<Users>();
		for (Users usuario : q.list()) {
			usuarios.add(new Users(usuario));
		}
		return usuarios;
	}

	/**
	 * Recupera todos los usuarios de la base de datos.
	 */
	public static List<Users> getAllUsuarios() {
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		Session session = sesion.openSession();
		String hql = "from Users";
		Query<Users> q = session.createQuery(hql, Users.class);
		List<Users> usuarios = new ArrayList<Users>();
		for (Users usuario : q.list()) {
			usuarios.add(new Users(usuario));
		}
		return usuarios;
	}

	/**
	 * Devuelve la lista de alumnos asociados a este profesor según las matrículas y horarios.
	 */
	@JsonIgnore
	public List<Users> getAlumnosbyProfesorID() {
		if (getId() == null) {
			throw new IllegalArgumentException("El id del profesor no puede ser nulo");
		}
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			String hql = "select distinct mat.users from Matriculaciones mat "
					+ "where mat.users.tipos.name = :nombre and exists (" + "select 1 from Horarios h "
					+ "where h.users = :usuario" + " and h.modulos.ciclos = mat.ciclos "
					+ "and h.modulos.curso = mat.curso)";
			Query<Users> q = session.createQuery(hql, Users.class);
			q.setParameter("nombre", "alumno");
			q.setParameter("usuario", this);
			List<Users> usuarios = new ArrayList<Users>();
			for (Users usuario : q.list()) {
				usuarios.add(new Users(usuario));
			}
			return usuarios;
		} catch (Exception e) {
			System.out.println("Error al obtener alumnos por ID de profesor: " + e.getMessage());
			throw e;
		}
	}

	/**
	 * Crea un nuevo usuario en la base de datos.
	 * Normaliza y cifra el username y la contraseña, y establece timestamps.
	 */
	public Users crearUsuario() {
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			Transaction tx = session.beginTransaction();
			String usernameNormalizado = getUsername().trim().toLowerCase();
			asegurarUsernameDisponible(usernameNormalizado, null);
			// Cifrado simétrico (clave SERVIDOR -> DB)
			setUsername(cifrar(usernameNormalizado, TIPO_SERVIDOR));
			setPassword(cifrar(getPassword(), TIPO_SERVIDOR));
			setId(null);

			// Timestamps
			Timestamp now = new Timestamp(System.currentTimeMillis());
			setCreatedAt(now);
			setUpdatedAt(now);
			session.persist(this);
			tx.commit();
			Users creado = session.get(Users.class, getId());
			return creado;
		} catch (Exception e) {
			e.printStackTrace();
			throw e;
		}
	}

	/**
	 * Actualiza un usuario existente en la base de datos con los datos de este objeto.
	 * Verifica disponibilidad de username y mantiene el tipo asociado si se proporciona.
	 */
	public Users actualizarUsuario() {
		if (getId() == null) {
			throw new IllegalArgumentException("Id obligatorio para actualizar usuario");
		}
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			Transaction tx = session.beginTransaction();
			Users existente = session.get(Users.class, getId());
			if (existente == null) {
				throw new RuntimeException("Usuario no encontrado con id: " + getId());
			}
			String usernameNormalizado = getUsername().trim().toLowerCase();
			asegurarUsernameDisponible(usernameNormalizado, existente.getId());
			if (getTipos() != null) {
				Tipos tipoGestionado = session.get(Tipos.class, getTipos().getId());
				existente.setTipos(tipoGestionado);
			}
			existente.setEmail(getEmail());
			existente.setUsername(cifrar(getUsername(), TIPO_SERVIDOR));
			existente.setUsername(cifrar(usernameNormalizado, TIPO_SERVIDOR));
			existente.setNombre(getNombre());
			existente.setApellidos(getApellidos());
			existente.setDni(getDni());
			existente.setDireccion(getDireccion());
			existente.setTelefono1(getTelefono1());
			existente.setTelefono2(getTelefono2());
			existente.setArgazkiaUrl(getArgazkiaUrl());
			existente.setUpdatedAt(new Timestamp(System.currentTimeMillis()));
			session.merge(existente);
			tx.commit();
			Users creado = session.get(Users.class, getId());
			return creado;
		} catch (Exception e) {
			throw e;
		}
	}

	/**
	 * Cambia la contraseña del usuario actual.
	 * */
	public Users cambiarPassword(String nuevaPassword) {
		if (getId() == null) {
			throw new IllegalArgumentException("Id obligatorio para cambiar la contraseña");
		}
		if (nuevaPassword == null || nuevaPassword.isBlank()) {
			throw new IllegalArgumentException("La nueva contraseña no puede estar vacía");
		}
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			Transaction tx = session.beginTransaction();
			Users existente = session.get(Users.class, getId());
			if (existente == null) {
				throw new RuntimeException("Usuario no encontrado con id: " + getId());
			}
				existente.setPassword(cifrar(nuevaPassword, TIPO_SERVIDOR));
			existente.setUpdatedAt(new Timestamp(System.currentTimeMillis()));
			session.merge(existente);
			tx.commit();
			return existente;
		} catch (Exception e) {
			throw e;
		}
	}

	/**
	 * Elimina el usuario de la base de datos identificado por este objeto.
	 */
	public void borrarUsuario() {
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			Transaction tx = null;
			try {
				tx = session.beginTransaction();
				Users u = session.get(Users.class, getId());
				if (u == null) {
					throw new RuntimeException("Usuario no encontrado con id: " + id);
				}
				session.remove(u);
				tx.commit();
			} catch (Exception e) {
				if (tx != null)
					tx.rollback();
				throw e;
			}
		} catch (Exception e) {

		}

	}

	/**
	 * Lanza una excepción si el username ya está registrado en la base de datos.
	 */
	private static void asegurarUsernameDisponible(String username, Integer excluirId) {
		if (usernameExiste(username, excluirId)) {
			throw new IllegalArgumentException("El nombre de usuario ya está en uso");
		}
	}

	/**
	 * Comprueba si un username ya existe en la base de datos.
	*/
	public static boolean usernameExiste(String username, Integer excluirId) {
		String usernameNormalizado = username.trim().toLowerCase();
		SessionFactory sesion = HibernateUtil.getSessionFactory();
		try (Session session = sesion.openSession()) {
			String hql = "select count(u) from Users u where u.username = :username";
			if (excluirId != null) {
				hql = hql + " and u <> :excluir";
			}
			Query<Long> q = session.createQuery(hql.toString(), Long.class);
			q.setParameter("username", cifrar(usernameNormalizado, TIPO_SERVIDOR));
			if (excluirId != null) {
				Users u = session.get(Users.class, excluirId);
				q.setParameter("excluir", u);
			}
			Long count = q.uniqueResult();
			return count != null && count > 0;
		}
	}


	/**
	 * Cifra usando el tipo indicado: "CLIENTE" o "SERVIDOR".
	 */
	public static String cifrar(String valor, String tipo) {
		if (valor == null) return null;
		String clave = TIPO_CLIENTE.equalsIgnoreCase(tipo) ? CLIENT_ENV_KEY : ENV_KEY;
		try {
			Cipher cipher = Cipher.getInstance(AES_TRANSFORMATION);
			cipher.init(Cipher.ENCRYPT_MODE, keyFromString(clave));
			byte[] cifrado = cipher.doFinal(valor.getBytes(StandardCharsets.UTF_8));
			return Base64.getEncoder().encodeToString(cifrado);
		} catch (Exception e) {
			throw new RuntimeException("Error cifrando valor", e);
		}
	}

	/**
	 * Descifra usando el tipo indicado: "CLIENTE" o "SERVIDOR".
	 */
	public static String descifrar(String valor, String tipo) {
		if (valor == null) return null;
		String clave = TIPO_CLIENTE.equalsIgnoreCase(tipo) ? CLIENT_ENV_KEY : ENV_KEY;
		try {
			Cipher cipher = Cipher.getInstance(AES_TRANSFORMATION);
			cipher.init(Cipher.DECRYPT_MODE, keyFromString(clave));
			byte[] decodificado = Base64.getDecoder().decode(valor);
			byte[] descifrado = cipher.doFinal(decodificado);
			return new String(descifrado, StandardCharsets.UTF_8);
		} catch (Exception e) {
			throw new RuntimeException("Error descifrando valor", e);
		}
	}


	/**
	 * Genera la clave AES a partir de la variable de entorno de configuración (clave concreta).
	 */
	@JsonIgnore
	private static SecretKeySpec keyFromString(String clave) {
		byte[] keyBytes = clave.getBytes(StandardCharsets.UTF_8);
		byte[] normalized = new byte[AES_KEY_LENGTH];
		for (int i = 0; i < AES_KEY_LENGTH; i++) {
			normalized[i] = i < keyBytes.length ? keyBytes[i] : 0;
		}
		return new SecretKeySpec(normalized, "AES");
	}
}
